apply plugin: 'java'

buildscript {
    repositories {
        if (project.hasProperty('local')) {
            mavenLocal()
        }
        mavenCentral()
        maven { url 'http://repository.activeeon.com/content/groups/proactive/' }
    }
}

subprojects {
    apply plugin: 'maven'

    group = 'org.ow2.proactive.r_connector'
    version = "${rConnectorVersion}"

    rootProject.buildscript.repositories.each {
        repositories.add(it)
    }

    configurations {
        addons
    }

    // rosuda jars are required for both par-connector and par-script
    dependencies {
        addons "org.rosuda:jriengine:0.5.x"
        addons "org.rosuda:jri:0.5.x"
        addons "org.rosuda:rengine:1.7.x"
    }
}

project(':par-script') {
    apply plugin: 'java'

    sourceCompatibility = 1.7

    dependencies {
        compile configurations.addons

        compile 'org.apache.commons:commons-lang3:3.1'
        compile group: 'com.google.guava', name: 'guava', version: '17.0'

        compile "org.objectweb.proactive:programming-extension-dataspaces:${programmingVersion}"
        compile "org.ow2.proactive:scheduler-api:${schedulingVersion}"
        compile "org.ow2.proactive:common-api:${schedulingVersion}"
        compile "org.ow2.proactive:rm-node:${schedulingVersion}"

        testCompile 'junit:junit:4.11'
        testCompile "org.ow2.proactive:scheduler-node:${schedulingVersion}"
    }

    task addon(type: Zip){
        from configurations.addons
        from jar
    }

    artifacts { archives addon }
    build.dependsOn(addon)
}

project(':par-connector') {
    apply plugin: 'base'

    configurations {
        scheduler
        restJars
    }

    dependencies {
        scheduler group: "org.ow2.proactive", name: "scheduling", version: schedulingVersion, ext: "zip"

        restJars 'xerces:xercesImpl:2.8.1'
        restJars "org.ow2.proactive_grid_cloud_portal:rest-client:${schedulingVersion}"
    }

    def isWindows = System.properties['os.name'].toLowerCase().contains('windows')
    def isMac = System.properties['os.name'].toLowerCase().contains('mac')
    def isLinux = System.properties['os.name'].toLowerCase().contains('linux')

    def rHome = System.getenv('R_HOME')
    def schedHome = "${rootProject.buildDir}/scheduler"
    def rSrc = "${buildDir}/r-pkg-src"

    def rExec
    def rScript
    if (isWindows) {
        def ARCH = System.getenv('ProgramFiles(x86)') != null ? 'x64' : 'i386'
        rExec = rHome ? rHome + File.separator + 'bin' + File.separator + ARCH + File.separator + 'R.exe' : 'R.exe'
        rScript = rHome ? rHome + File.separator + 'bin' + File.separator + ARCH + File.separator + 'Rscript.exe' : 'Rscript.exe'
    } else {
        rExec = rHome ? rHome + File.separator + 'bin' + File.separator + 'R' : 'R'
        rScript = rHome ? rHome + File.separator + 'bin' + File.separator + 'Rscript' : 'Rscript'
    }

    def env = [:]
    env.putAll(System.getenv())
    if (!isMac) {
        env.put('JAVA_HOME', env.get('JAVA_HOME') + File.separator + 'jre')
    }
    if (isLinux) {
        def ldLib
        if (System.getProperty('os.arch').contains('64')) {
            ldLib = new File(env.get('JAVA_HOME'), 'lib/amd64/server')
        } else {
            ldLib = new File(env.get('JAVA_HOME'), 'lib/i386/client')
        }
        env.put('LD_LIBRARY_PATH', ldLib.getAbsolutePath())
    }

    def schedProcess

    task copyRSources(type: Copy) {
        from "${projectDir}/src/main/r"
        include("**/*")
        exclude("**/.*")
        into rSrc
    }



    task updateVersion(dependsOn: copyRSources) << {
        def descFile = file("${rSrc}/DESCRIPTION")
        def pattern = java.util.regex.Pattern.compile("Version: ((\\d+\\.)*(\\d+))")
        def v = "${rConnectorVersion}".replace("-SNAPSHOT","")
        def matcher = pattern.matcher(descFile.getText())
        matcher.find()
        def descFileContent = matcher.replaceFirst("Version: " + v)
        descFile.write(descFileContent)
    }

    task copyRDependencies(type: Copy) {
        from configurations.restJars
        into "${rSrc}/inst/java"
    }

    task generateDocumentation(type: Exec, dependsOn: [copyRSources, updateVersion, copyRDependencies]) {
        inputs.dir(rSrc)
        outputs.dir(buildDir)
        workingDir rSrc
        commandLine rExec, '-e', 'library(devtools);document()'
        environment env
    }

    task addLibsToNamespace(dependsOn: generateDocumentation) << {
        def descFile = file("${rSrc}/NAMESPACE")
        def nl = System.getProperty("line.separator")
        def text = descFile.getText()
        text = text.concat(nl + "import(rJava, stringr, codetools, devtools, gtools)" + nl)
        descFile.write(text)
    }

    task checkRPackage(type: Exec, dependsOn: [addLibsToNamespace, generateDocumentation, copyRSources, updateVersion, copyRDependencies]) {
        inputs.dir(rSrc)
        outputs.dir(buildDir)
        workingDir buildDir
        commandLine rExec, 'CMD', 'check', '--no-codoc', '--no-manual', '--no-multiarch', rSrc
        environment env
    }

    task buildRPackage(type: Exec, dependsOn: [copyRSources, updateVersion, copyRDependencies, checkRPackage]) {
        inputs.dir(rSrc)
        outputs.dir(buildDir)
        workingDir buildDir
        commandLine rExec, 'CMD', 'INSTALL', '--build', '--preclean', '--with-keep.source', '--no-multiarch', rSrc
        environment env
    }
    task build(dependsOn: buildRPackage)

    task reinstallRPackage(dependsOn: buildRPackage) << {
        def rLibs
        if (isWindows) {
            rLibs = new File(rHome, 'library')
        } else {
            assert System.getenv('R_LIBS') : 'R_LIBS must be defined'
            rLibs = file(System.getenv('R_LIBS'))
        }
        assert rLibs.exists(): 'Unable to locate r libs'

        logger.info('Removing previous installation ...')
        exec {
            workingDir buildDir
            commandLine rExec, 'CMD', 'REMOVE', '--library=' + rLibs.getAbsolutePath(), 'PARConnector'
            environment env
        }

        logger.info('Reinstallling ...')
        def packageFile = file(buildDir).listFiles().find {
            it.name.endsWith('tar.gz') ||
                    it.name.endsWith('tgz') ||
                    it.name.endsWith('zip') }
        exec {
            workingDir buildDir
            commandLine rExec, 'CMD', 'INSTALL', '--no-multiarch', '--library=' + rLibs.getAbsolutePath(), packageFile.getAbsolutePath()
            environment env
        }
    }

    task installJars(type: Copy) {
        from project(':par-script').jar
        from configurations.addons
        into "${schedHome}/addons"
    }

    // The following task will unzip the scheduler project into build/scheduler dir
    task distScheduler(type: Copy) {
        from mainArtifactsAsZipTree(configurations.scheduler)
        into "${rootProject.buildDir}/scheduler"
        eachFile { fileCopyDetails ->
            fileCopyDetails.path = fileCopyDetails.path.replaceAll(/(.*\/?)scheduling-${schedulingVersion}\/(.*)/, '$1$2')
        }
        includeEmptyDirs = false
    }

    task startScheduler(dependsOn: [distScheduler, installJars, reinstallRPackage]) << {
        schedProcess = ['java', '-classpath', 'dist/lib/*', 'org.ow2.proactive.scheduler.util.SchedulerStarter', '-ln', '2'].execute(null, new File(schedHome))
        try {
            schedProcess.inputStream.eachLine {
                println '>> ' + it
                if (it.contains('rest created')) {
                    throw new Exception()
                }
            }
        } catch (ignored) {
        }

        try {
            int value = schedProcess.exitValue();
            if (value != 0) {
                throw new Exception('Could not start the Scheduler java exited with code ' + value);
            }
        } catch (IllegalThreadStateException e) {/* the process is still running */
        }
    }

    task runFuncTests(dependsOn: startScheduler) << {
        def funcTestsDir = file("${projectDir}/src/main/test/r/functionalTests")
        try {
            funcTestsDir.listFiles().each {
                if (it.getName().startsWith('test')) {
                    println '\n######################\n#   RUNNING functional test ' + it + ' ... \n######################'
                    def toRun = "" + it.getAbsolutePath()
                    exec {
                        workingDir funcTestsDir
                        commandLine rScript, '--slave', '--verbose', '--no-save', '--no-restore-history', toRun, 'QUITONERROR'
                        environment env
                    }
                }
            }
        } finally {
            println '\n######################\n#   SHUTTING down the Scheduler ... \n######################'
            // Use client to remove 'LocalNodes' node source to avoid orphan nodes processes
            def clientProcess = ['java', '-classpath', 'dist/lib/*', 'org.ow2.proactive_grid_cloud_portal.cli.CommonEntryPoint',
                                 '-l', 'admin', '-p', 'admin', '-r', 'LocalNodes'].execute(null, new File(schedHome))
            try {
                clientProcess.inputStream.eachLine {
                    println '>> ' + it
                    if (it.contains('deleted successfully'))
                        throw new Exception()
                }
            } catch (e) {
            }
            schedProcess.destroy();
        }
    }
}

def mainArtifacts(configuration) {
    configuration.resolvedConfiguration.firstLevelModuleDependencies.moduleArtifacts.file
}

def mainArtifactsAsZipTree(configuration) {
    zipTree(mainArtifacts(configuration)[0][0])
}
